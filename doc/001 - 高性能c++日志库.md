# 001 - 高性能c++日志库

# 背景

大规模分布式系统中, 系统的可观测性是一个待解决的问题,如何以低代码的方式保证并发安全,低性能成本的方式实现高可靠的日志库是实现可观测性的重要手段。同时在学习高性能日志库的实现过程中,我们能够体会到高性能编程的设计原则,以及其中所涉及到的Linux内核原理。

日志库作为一个最基础的组件，既要保证性能，又要保证实用。如何玩转高性能日志，可以说是基础架构研发的HelloWorld,在日志库的研发过程中程序员将领会一些软件设计中的基本问题。现有的日志库如boost.log/glog/log4j等等代码都过于庞大，并不适合提炼出日志库的精髓，因此本文将会手把手带领大家实现一个支持同步/异步等方式的日志库。

# 需求列表

1.  动态修改日志库的配置参数
2.  同步,异步的方式写入日志(字节流)到对端(文件,网络,数据库)
3.  通过回调函数,实现用户自定义逻辑可插拔式注入
4.  高性能高可靠的同时将日志写入多种对端(文件,网络,数据库)


# 关于日志库的核心问题

1.  如何自定义日志的格式?

不同场景下 需要的定制化信息是不同的,例如分布式场景下每一个请求都需要一个reqid（request id pid tid）进行标识,所以如何把对输入的日志消息进行统一的格式化是很必要的事情。

2.  如何动态的修改日志级别？（并发，原子性，枚举类）

由于使用枚举来表示日志级别，而8位整型取值和赋值本身就是原子的，无需担心；

3.  如何平衡磁盘与内存的IO效率?

我们知道计算机组成中，磁盘最慢，因此在系统中我们一般不会同步刷盘，而是单独的后台线程来负责日志的持久化(生产者消费者模式)

4.  多线程的写入日志时如何保证并发安全?

多线程写日志存在安全问题，本身需要加锁，正是由于需要加锁，反而会降低写文件的效率。所以常见的日志库大多采用多生产单消费者方式来写文件,一个可行的优化，就是使用[[双buffer机制]]，来避免每次生产者向队列中push一条消息时，都要唤醒消费者。使用双buffer本质其实是批操作。 如何设计一个并发安全的高性能buffer是日志库设计的关键所在。

5.  如何刷盘?何时滚动日志?
    1.  滚动要在时间与空间上进行控制同时也要避免空转
    2.  通过写入次数大于一个阈值的方法来避免写入次数过少的情况下 滚动与刷新日志
6.  如何减少刷盘的次数从而提升性能?
    1.  在这里使用[[mmap]]机制，减少日志数据的拷贝次数
    2.  mmap 的设计与实现
7.  如何保证日志库的高可靠?一定能写到对端?
    1.  在程序异常退出时 通过[[哨兵机制]]保证进程崩溃时日志不丢失
        1.  使用静态函数指针 标识buffer内存空间
        2.  当msg 被写入buffer的时候 如果程序崩溃 可以通过 coredump中静态函数名称以及指针找到
    2.  Coredump 文件被覆盖了怎么办?
        1.  为了避免新的core覆盖掉旧的core文件，会单独设置core文件的格式和路径(/proc/sys/kernel/core_pattern里设置core文件的文件名模板，详情请看core的官方man手册)
8.  如何使日志库更方便于用户扩展功能?
    1.  用户在使用日志库时，可能需要自定义一些扩展的功能，如黑名单机制(日志中包括某些敏感内容的，不会输出到日志)
9.  多线程情况下如何处理信号问题?
    1.  由于信号是进程维度，所以当发生信号时，他是随机发向某个线程的。有两种方式处理信号：信号捕捉和sigwait。日志库是不能被信号中断，所以需要注册回调函数，来屏蔽指定的信号。

![[Pasted image 20211223203532.png]]

![[Pasted image 20211223203553.png]]



# 总结与展望

## 并发编程的设计原则

1.  减少锁的竞争
    1.  **使用双buffer，来减少锁的竞争，以及避免频繁被唤醒**
    2. [[双缓冲机制]]
2.  适当使用tls来提升性能

## 关于日志库的QA

1.  为什么要有日志库？printf不行吗？
2.  如何区分日志级别？日志级别支持动态修改吗？
3.  同步日志跟异步日志如何实现？
4.  如何将日志输出到不同的文件，一般提供哪些切分日志的方式？如何切分，删除呢？
5.  日志输出到文件有什么加速的技巧？
6.  如何保证多线程打印文件而不串？
7.  为何一般应用程序都要再包装一层接口，目的是什么？